January 29, 2006

EPS file grid.eps lists (1) entries in column-major order.


January 30, 2006

Changed all (1) in template to (-)


Got sudoku back tracking to work for any number of hints greater than 26.

New command line:

sudoku 3 28

generates puzzle number 3 (using seed 3) with 28 hints.



January 31, 2006

sudoku 3 29  has more than one solution... ugg..

Found a bug in getBlockmates... fixed it

But now it is much harder to get a puzzle with 27 hints (10963 backtracks).

Maybe need to tweak backtrack parameters a bit now that getBlockmates is fixed.



March 14, 2006

North Country This Week wants to run one puzzle a week.  Cool.

Shrunk the instructions a bit according to their suggestion (10% leading).

They want TIFFs at 400 dpi.

4-inch-wide puzzle is then 1600 pixels wide
1.75-inch-wide solution is then 700


For conversion to TIFF, mogrify works, but it introduces artifacts:

mogrify -format tiff -geometry 1050x1050 -colors 2 +dither +antialias 1_solution.eps

B+W Tiff generated by GIMP (portable, with no compression) is over 1MiB for
600 dpi.

Skipping this for now, unless they really need it.  Sending both EPS and PDF
instead.





March 30, 2006

The "hard" puzzles can be solved by simple logic without any special techniques
at all.  Thus, they are not really hard (even though they only contain 28 
hints).

Actually, the number of hints has nothing to do with puzzle hardness.

Evidence:  often a hard puzzle gets harder near the end, after many blank
cells have been filled in.


For my puzzles, the online solver (http://www.sudokusolver.co.uk/) never
resorts to any special techniques.

I can also solve my hardest puzzles by hand in a few minutes using the simple
process of elimination.

I have improved my constrained cell detector somewhat so that it blanks cells
that it previously avoided blanking.

However, there is still more work to do here.

Ideally, it should be able to blank a cell if setting the cell to any other
value leads to an unsolvable puzzle.



April 2, 2006

That last idea (blanking a cell if any other possible values lead to 
unsolvable puzzles) is really guess-n-check, which results in a puzzle where
guess-n-check is necessary to solve it.

We should avoid this.

Latest idea:

Blank a cell and then run a solver.
Does solver discover value for the cell?
If so, then keep the cell blank.
If not, then refill the cell.

The sophistication of the solver (the techniques it uses) will determine
the sophistication of the puzzle.

Coding this for a simple solver (iteratively fill in cells that have only
one possible value) works, but puzzles are solvable using the simplest logic
only.  Discovered solvable puzzles with only 22 hints---cool.

Added slightly more advanced solving method.

Online solver resorts to method A to solve.

Trying to integrate even more advanced solving method.

"Look at a row in the solution grid to see if there is a group of N cells 
which contain only N possible numbers. If such a 'chain' exists, then those 
cells must contain these numbers, so we can eliminate these numbers from 
other cells in the row."

See fixme in code:  How to generate subsets?



April 3, 2006

Figured out how to generate subsets in this case (counting method)

However, still can never generate a puzzle that is solvable with N-chain method
but unsolvable with simpler methods.

Maybe the template puzzle itself is too simple...

Try to find a "hard" template.

Indeed, testing with an "evil" solution template from WebSudoku, my puzzle
algorithm finds cells that can only be blanked using the hard solver.

The resulting puzzle is much harder.

Maybe I can generate random solution grids from scratch.

But how to be sure they are hard?

On a message board, Dom writes:

"Basically it selects a random number for cell 1, checks the grid is valid (always true), selects a number for cell 2, checks the grid is valid, selects a number for cell 3, checks the grid is valid, etc..

"When the grid isn't valid a different random number is tried in that cell.

"When all values have been tried in that cell the recursion backs up one, and other values are tried in the previous cell. The algorithm carries on going forwards and backwards like that until it reaches the 81st cell, at which point the grid is complete."

Try something like this, see if result is hard.



April 4, 2006

Another track:

Rewrote solver from scratch so that it is based refining a list of possible
values for each cell.

Works much better, and it's much easier to implement more advanced solve
methods in this framework.

Got A, B, and C methods discribed at http://www.sudokusolver.co.uk/ implemented
and working.  Can now solve "evil" puzzles from WebSudoku.

Can also generate somewhat harder puzzles.

Still have never generated a puzzle where method C was required to solve it.
Evil puzzle required method C.

Even using evil solution as template... never generated a puzzle that required
C to solve it.


Idea:  when removing a number, pick number that results in puzzle that is
hardest to solve.

Also try random solution (full grid) generation (recursion) mentioned above...
can even pick values that lead to the hardest puzzles, at least for later 
values.



April 9, 2006

Got method D working in solver.

Wrote a recursive remover that tries to find the blank cells that lead to the
hardest puzzle.

Using this remover, found hard puzzles that require all four methods.

Hardest score seen with this method:  250
Time taken to find this puzzle:  1 minute 43 seconds
(code compiled with optimizations off)


Another recursive idea:

Try starting with an empty grid and placing values in cells.

If value leads to a contradiction, try another value.
If all values lead to a contradiction, backtrack in recursion.

If value leads to a solvable puzzle, and score is hard enough, stop (success)
If score not hard enough, try another value.

If score not hard enough or contradiction found for all values, backtrack in
recursion.


Implemented this.  Still seem to be some bugs (look at stepsRemaining counter).


Fixed bugs in recursive adder.  Now it does the right thing, but it never
discovers solvable puzzles.

Maybe I should write a different recursive adder that just tries to generate
a full grid.


Did this.  Can generate about 200 puzzles per second.

Optimized with profiler.  Can generate 400 puzzles per second.

Coupling with the recursive remover, we can generate hard puzzles.  How
to make it faster, though?  Still takes on the order of 1 minute to
generate a hard puzzle.

One idea:  Start with a very hard puzzle as a template (including its blanks),
transform it randomly, and then solve it somewhat to get easier puzzles.

We could write a solver that can hit a particular score on the nose by filling
in some values.


This seems cheap, in that people will really be solving the same puzzle again
and again.


April 10, 2006

What about a simple generator that is really fast?

We can generate 400 full puzzles per second.  What about a slimmed-down
remover that stops as soon as the puzzle is unsolvable?


Even slimmed-down remover is somewhat slow (about 1 puzzle per second).

Problem:  solver runs at about 61 puzzles per second (hard puzzles).
Slimmed-down remover calls solver around 81 times to generate a puzzle.


New idea:

Start with blank grid, but keep solution in mind.

Repeat while unsolvable:
   Run solver on copy of grid
   if unsolvable
      pick cell that is still blank (after solver done) in grid copy
      set that cell in main grid to value from solution.


Further refinements:
Pick cell to set value for based on which cell is most (or least?) constrained
according to solver.  This may lead us to hard puzzles.


This works, especially with refinements, to find hard puzzles.


To make them even harder:

--Fill blank puzzle with solution values until solvable
--Run remover, which removes values as long as still solvable


We can even iterate this process, which should find hard puzzles:

Repeat:
--Fill puzzle till solvable
--Remove unneeded values
--Remove a few extra values


With this method, saw a puzzle with a score of 251 (hardest ever seen)
|-  4  3 |-  -  - |2  -  8|
|-  -  - |-  -  8 |-  -  -|
|-  6  - |-  -  4 |7  -  -|
---------------------------
|3  -  5 |-  -  - |1  -  -|
|-  2  - |-  -  - |-  5  3|
|6  -  - |7  -  - |-  -  -|
---------------------------
|-  -  - |-  9  - |-  -  7|
|9  1  - |6  -  - |-  -  -|
|-  -  2 |-  1  - |4  -  -|


Still need to refine this a bit more


April 11, 2006

Seems like we should apply something from the AI search algorithm toolbox here.

We are looking For the hardest possible sudoku with a given solution.

Given a solution s, we have a function f_s(x) that maps 81-bit numbers (the
locations of the hints) to hardness scores.

We want to find x' that maximizes f_s(x').

First, we might try just walking through the space of possible x values and
graphing f_s(x) to get a feel for the space.

Tried this.  Need to start at a valid puzzle to avoid parts of the space
(such as all blank) that are filled with unsolvable puzzles.

Output is somewhat interesting.  Ready to try hill climbing by flipping
bits. 


Idea:

Start with a puzzle P

Flip bits to get P'

If P' harder than P
Recurse onto P'

If no P' is harder than P, return (P is a local max)


This seems to work very well and quickly finds hard puzzles.

Example output (16 seconds):
New score 64
New score 67
New score 100
New score 106
New score 112
New score 115
New score 121
New score 130
New score 133
New score 137
New score 145
New score 148
New score 151
New score 159
New score 162
New score 206

Stalled at 206 mark


Letting it run a bit longer, we see the hardest puzzle my algs have ever
discovered:

New score 64
New score 67
New score 100
New score 106
New score 112
New score 115
New score 121
New score 130
New score 133
New score 137
New score 145
New score 148
New score 151
New score 159
New score 162
New score 206
Failed to find puzzle with score harder than 206 at this branch
New score 206
New score 269
New score 272
New score 275
Failed to find puzzle with score harder than 275 at this branch
New score 275


But it takes a long time before it decides to back out of a branch.

It must try all pairs i and j.

Maybe it should just pick one spot and swap it... try this.

Tried this... didn't get past 180s after over 2 minutes


Better:  try swapping pairs, but don't only consider pairs where one is blank
and the other is full.

Consider all pairs.

Saw new high score with this method (286).  Very fast:  54 seconds.


What about trying triples to swap?  Would it work better than pairs?



April 12, 2006

When trying pairs to blank
Seed 1
Got to 143 in 23 seconds.

Try triples to blank


This improves performance in some cases and degrades it in others.

Idea:  we're still computing the score of each improved puzzle twice (once
when testing it, and once in the recursive call).  Test if changing this
improves things at all:

Old:  reached 145 (seed 1) in 14.7 seconds.
New:  14.3 seconds

No improvement.



Trying fastRemove in middle of hill climbing.

Usually improves puzzle score.

In some strange cases, it makes the puzzle *easier* by setting more cells to
blank, at least according to the solver's scoring.

Example:

This score (54 blanks) = 129, refined score (54 blanks) = 123
HUH?  score went down when cells blanked?
This puzzle:
Basic method count:  29
Method A count:  25
Method B count:  0
Method C count:  0
Method D count:  0 {0}  0 {1}  0 {2}  0 {3}  0 {4}  0 {5}  0 {6}  0 {7}  0 {8}  0 {9}  
|-  -  6 |-  5  - |-  -  -|
|-  2  - |6  -  - |4  -  -|
|5  9  7 |-  8  - |-  -  -|
---------------------------
|-  4  - |-  -  - |3  -  9|
|6  -  - |-  -  9 |-  -  -|
|7  -  - |4  -  6 |-  5  -|
---------------------------
|-  -  4 |-  -  - |-  8  -|
|-  6  - |5  -  - |-  7  3|
|-  -  - |-  1  - |9  -  6|
__6_5____+_2_6__4__+597_8____+_4____3_9+6____9___+7__4_6_5_+__4____8_+_6_5___73+____1_9_6
Refined puzzle:
Basic method count:  35
Method A count:  22
Method B count:  0
Method C count:  0
Method D count:  0 {0}  0 {1}  0 {2}  0 {3}  0 {4}  0 {5}  0 {6}  0 {7}  0 {8}  0 {9}  
|-  -  6 |-  5  - |-  -  -|
|-  2  - |6  -  - |4  -  -|
|5  9  7 |-  8  - |-  -  -|
---------------------------
|-  4  - |-  -  - |3  -  9|
|6  -  - |-  -  9 |-  -  -|
|7  -  - |4  -  6 |-  5  -|
---------------------------
|-  -  4 |-  -  - |-  8  -|
|-  -  - |5  -  - |-  7  -|
|-  -  - |-  1  - |-  -  6|
__6_5____+_2_6__4__+597_8____+_4____3_9+6____9___+7__4_6_5_+__4____8_+___5___7_+____1___6


The funny thing is that http://www.sudokusolver.co.uk agrees with this (their
score went down from 129 to 123 when additional cells were blanked).

Looking at my code, this seems to be caused by the choice of where to apply
algorithm A.  Some places yield more resulting solvable cells than others (and
thus, less resorting to alg A in the future).

Seems that blanking these addition cells results in us picking  *more* 
fruitful places to apply method A.

We could fix this, perhaps, by looking for the "best" place to apply A using
some heuristic.  For example, we could search through all possible places
to apply A and pick the one that results in the most values being removed
from the intersecting groups.

This is probably not worth the work, however, since it would slow the solver
down.  Also, I haven't seen scores changing *that* much.

We should always assume that for human solvers, a puzzle always becomes harder
as more cells are turned blank.


So, try refining as first step of recursive call.

Before:
Got to 162 (seed 1) in 16.8 seconds.

After:
Stalls at 105 and then at 145

Problem:
Not enough slack for the search to explore.
Okay, so don't do this.

However, we should do this as a final step after we find the hardest puzzle
we can find and give up.


Also, go back to searching for pairs instead of triples.

Removed triple and single trying code.  Now pairs only.


General idea:

Repeat, looking hard puzzle with score S:
--Pick a solution grid.
--Run fast fill on it.
--Hill climb for a while to find a hard puzzle)
--Fast remove result (to further refine the hard puzzle)


April 13, 2006

Idea to improve hill climbing:

Sometimes it gets stuck for a long time at a local maximum checking all 
possible swaps.  We can detect this condition by counting how many swaps we
have tried since we made progress and giving up after a certain number.

Experiments show that this improves performance.  But what value?

Experiment:  how long does it take ./sudoku 3 24 to reach a score of 212

Baseline (keep going until all pairs tried):  1m 27 seconds
Stop after 100 failures:                      over 2m 43 sec
Stop after 150 failures:                      1m 48 sec
Stop after 200 failures:                      23 seconds
Stop after 250 failures:                      56 seconds
Stop after 300 failures:                      36 seconds
Stop after 301 failures:                      36 seconds
Stop after 300 failures:                      1m 10 seconds
Stop after 500 failures:                      1m 3 seconds
 


Wow.  ./sudoku 3 24  , giving up after 200 consecutive failures, found puzzle
with score of 377... the highest ever seen.

Hit 377 after 2m 33 seconds.


Obviously, the effect of the "consecutive failures" parameter on the speed
of improvement is non-linear, at least for specific examples.  The effect
may have more do with a different mix of the random number generator.

Idea:  Experiment to graph effect on average.
Make the consecutive failures parameter an argument of hillClimb

Note:  by stopping at each branch after 50 consecutive failures, reached a
score of 420 (highest ever), though it took a while.


Experiment showed that parameter has no effect, even averaging 10 samples per
parameter value:

p   average msec to reach 130
25  3723
50  1828
75  4445
100  1476
125  3082
150  4119
175  2762
200  1949
225  3713
250  7447
275  5209
300  2681
325  3098
350  1645
375  2578
400  2878
425  4341
450  4078
475  2279
500  8314


Maybe it was because 130 is such a low score that all parameter settings easily
reach it.


What about annealing-style technique?

Start with low parameter value, which means we give up quickly and bounce
around a lot in the solution space.  Find the hardest puzzle in 10 seconds that
way, and then stop.

Increase parameter, and then start searching again from the puzzle that was
found, again stopping after 10 seconds.  With an increased parameter, we
do a more comprehensive search.


When running same experiment searching for scores of 200 (average time over
3 samples), we get these results:

100  35991
200  72663
300  154424


So, obviously, lower parameter values are better for reaching somewhat higher
scores.



Got annealing in place that searches for a desired score.

Times allowed at each "temperature" level increase as it fails to find 
satisfying puzzle.


April 14, 2006

Problem:

When time factor gets too high, getting through the round takes too long.

Idea:  jump back to time factor of 1 after a while.

New problem:  never finds very hard puzzles.  Ran for an hour.  Hardest
puzzle found was 341.  Example output:


    timeFactor = 1
New hardest score = 161
    timeFactor = 2
New hardest score = 241
    timeFactor = 3
    saw score = 207
    timeFactor = 4
New hardest score = 279
   rolling time factor back to 1
    timeFactor = 1
    saw score = 175
    timeFactor = 2
    saw score = 167
    timeFactor = 3
    saw score = 155
    timeFactor = 4
New hardest score = 341
   rolling time factor back to 1
    timeFactor = 1
    saw score = 161
    timeFactor = 2
    saw score = 270
    timeFactor = 3
    saw score = 193
    timeFactor = 4
    saw score = 119
   rolling time factor back to 1
    timeFactor = 1
    saw score = 175
    timeFactor = 2
    saw score = 206
    timeFactor = 3
    saw score = 208
    timeFactor = 4
    saw score = 316
   rolling time factor back to 1
    timeFactor = 1
    saw score = 201
    timeFactor = 2
    saw score = 164
    timeFactor = 3
    saw score = 147
    timeFactor = 4
    saw score = 162
   rolling time factor back to 1
    timeFactor = 1
    saw score = 209
    timeFactor = 2
    saw score = 242
    timeFactor = 3
    saw score = 218
    timeFactor = 4
    saw score = 165
   rolling time factor back to 1
    timeFactor = 1
    saw score = 123
    timeFactor = 2
    saw score = 195
    timeFactor = 3
    saw score = 339
    timeFactor = 4
    saw score = 154
   rolling time factor back to 1
    timeFactor = 1
    saw score = 205



Looking for that 420 puzzle just to keep it and try it myself.

Noticed that with latest hill climbing algorithm, cannot find the 420 puzzle.

Question: which one makes sense? 
(1)  if( newPuzzleScore > hardestScoreSeen ) {
or
(2)  if( newPuzzleScore > thisPuzzleScore ) {

If we only examine steps that lead to even harder scores than we've seen at
this level, then we are essentially only considering *steeper* slopes than
we have already found.  This does not make sense, since maybe we need to go
on a less-steep slope to get around a local maximum.

Switched back to (2) and was able to find the 420 puzzle again

./sudoku 3 24  giving up after 50 consecutive failures.

Found 420 in 3m27 seconds.



Okay... here it is, along with its refined cousin:


Puzzle:
|-  -  7 |8  -  - |-  9  -|
|-  -  - |-  9  - |-  -  7|
|9  -  - |-  -  2 |8  -  -|
---------------------------
|-  -  - |4  -  - |-  -  -|
|-  4  - |3  -  6 |7  -  -|
|-  8  6 |9  -  7 |1  4  -|
---------------------------
|1  -  5 |-  3  - |-  -  -|
|-  -  - |-  -  4 |6  8  1|
|-  6  - |-  -  - |3  -  -|

__78___9_+____9___7+9____28__+___4_____+_4_3_67__+_869_714_+1_5_3____+_____4681+_6____3__
Solution:
|4  1  7 |8  6  3 |5  9  2|
|6  2  8 |1  9  5 |4  3  7|
|9  5  3 |7  4  2 |8  1  6|
---------------------------
|7  3  9 |4  5  1 |2  6  8|
|2  4  1 |3  8  6 |7  5  9|
|5  8  6 |9  2  7 |1  4  3|
---------------------------
|1  7  5 |6  3  8 |9  2  4|
|3  9  2 |5  7  4 |6  8  1|
|8  6  4 |2  1  9 |3  7  5|
Base score: 420, refined score: 372
Refined puzzle:
|-  -  7 |8  -  - |-  9  -|
|-  -  - |-  9  - |-  -  7|
|9  -  - |-  -  2 |8  -  -|
---------------------------
|-  -  - |4  -  - |-  -  -|
|-  4  - |3  -  6 |7  -  -|
|-  8  6 |9  -  7 |-  4  -|
---------------------------
|1  -  5 |-  3  - |-  -  -|
|-  -  - |-  -  4 |6  8  1|
|-  6  - |-  -  - |-  -  -|



Now, there is still the question about whether we "roll back" to exploring our
base puzzle state after failing to find improvement when exploring a 
higher-score sub branch.

The 420 puzzle was found with the roll-back turned off.  However, the roll
back makes sense (otherwise, we are re-exploring the branch that we have 
already given up exploring).  How hard of a puzzle can be found with roll back
turned on?

With roll back turned on, it barely broke 300 after 25 minutes.

With other seed values, didn't see a difference between roll back on and off.

It probably depends on exploring good branches, so it's mostly random chance.

Roll-back does make sense (since we want to return to this branch's state).

However, not rolling back makes sense too.
Suppose that this branch puzzle has a score of 100 and the next branch puzzle 
has a score of 120.  Maybe we explore that branch and never find a step that 
leads to a score higher than 120.  So we back out of that branch.  If we roll
back, we return to our 100 puzzle and explore it, looking for other steps
that lead to scores higher than 100.

But if we don't roll back, we start from the 120 puzzle and look for steps
to take from *it* that lead to scores higher than 100.  Maybe we find
a step that leads to 119, for example.  Maybe from the 119 branch, we can find
a step that leads to 125.

But maybe there is no step from the 100 puzzle that leads to a 119 or 125 
puzzle.



Okay, returned hillClimb to old state (no roll back).


Problem with annealing:

We stop at each parameter level after a particular time has passed, but there
is no guarantee that we stop on the *best* puzzle found at that level.

Need to track the best seen so far.


Old (./sudoku 3 24):
    timeFactor = 1
New hardest score = 161
    timeFactor = 2
New hardest score = 186
    timeFactor = 3
New hardest score = 239
    timeFactor = 4
    saw score = 110
   rolling time factor back to 1
    timeFactor = 1
    saw score = 194
    timeFactor = 2

New:
    timeFactor = 1
New hardest score = 123
    timeFactor = 2
New hardest score = 152
    timeFactor = 3
New hardest score = 158
    timeFactor = 4
    saw score = 117
   rolling time factor back to 1
    timeFactor = 1
    saw score = 110
    timeFactor = 2
    saw score = 97


Much worse.  Logic:  the very best state we have seen is probably at a dead
end.  So we don't want to continue exploration from that point.

However, at final stage (before really giving up), it does make sense to
see the best score we ever discovered.

No... we are shooting for a particular score.  If we don't discover it, it
doesn't matter how close we got on our best explored puzzle.

So, tear out code that returns the best discovered puzzle on failure.


Maybe just straight hill climbing, with some chosen parameter value, will
work better than this increasing-parameter approach.

Instead, try hill climbing for a while with one parameter, then start over from
scratch with the same parameter.

Do this 10 times.  Then increase the time and start over again.

Try timing each approach (time it takes to reach score of 200)


Times for increasing parameter method

Seed   time
3      33.7
4      22
5      1m14
6      41
7      17
8      2m50

Average:  59.6 sec

Times for set parameter method (10 tries at each level):

Seed    time
3       27
4       22
5       16
6       1m9
7       50
8       2m9

Average:  52 sec


Slightly better.  What about fewer tries at each level?  No, because sometimes
our high score was discovered at the first level.


Trying with param of 100

 timeFactor = 1
Try 0
New hardest score = 152
Try 1
New hardest score = 163
Try 2
    saw score = 153
Try 3
    saw score = 149
Try 4
    saw score = 135
Try 5
    saw score = 163
Try 6
    saw score = 163
Try 7
    saw score = 110
Try 8
    saw score = 123
Try 9
    saw score = 125

Average score:  143.6



Trying with param of 50

Try 0
New hardest score = 146
Try 1
    saw score = 137
Try 2
    saw score = 141
Try 3
New hardest score = 148
Try 4
New hardest score = 184
Try 5
    saw score = 125
Try 6
    saw score = 127
Try 7
    saw score = 144
Try 8
    saw score = 159
Try 9
New hardest score = 195
    timeFactor = 2

Average score:  150.6



Trying with a param of 25

Try 0
New hardest score = 186
Try 1
    saw score = 167
Try 2
    saw score = 149
Try 3
New hardest score = 198
Try 4
    saw score = 123
Try 5
    saw score = 157
Try 6
    saw score = 123
Try 7
    saw score = 141
Try 8
    saw score = 147
Try 9
    saw score = 129

Average score:  152


Stick with 50 anyway, since I feel like I've had good luck with it.



Okay, so this is in place.  We know 50 is a good parameter, because it was
able to discover the hardest puzzle seen so far (420).

Time to clean up sudoku.cpp so that it is actually usable for generating
puzzles with a given score.

Check in first.



Old classification

// easy: 34-37 hints
// medium: 31-33 hints	
// hard:   27-30 hints

New classifications:


Old classifications marked puzzles with score of 54 as hard.  Really, just
like any puzzles that require only the basic method, they were easy.

Unfortunately, one of these "hard" puzzles was already sent to NCTW.

Better to jump right into a better classification scheme instead of trying
to blend the scheme so that works with the old scheme (after all, NCTW is
just the tip of the iceberg anyway).

Anything below 60 can probably be solved only using the basic method.
So, these are Easy.

Once you get higher than 60, you have puzzles that probably at least require
method A.  So these are medium.  Maybe 60 to 100.

It would be hard to imagine puzzles over 100 that only required A.

So these are Hard.  100 to 150.

Over 150 probably requires C, so these are Extreme... maybe up to 300

Over 300... now that is Severe

Extreme and Severe can be confused---which sounds harder?

Better:

Easy
Medium
Hard
Intense
Severe


Map:

0   -  60  Easy
61  - 100  Medium
101 - 150  Hard
151 - 300  Intense
301 +      Severe



So far, for NCTW:
easy
easy
easy
medium
medium
hard


Next (using new map):
medium
hard
intense
severe



Still to do:

Our search method finds a puzzle that is at least as hard as a given score.

But, for example, if we run ./sudoku 3 50, we get a puzzle with a score of 68.

Even the starting point we are generating is "too hard," so our hill climber
returns right away.

We should add a parameter to solver that will force it to return after making
one step of progress.  Thus, we can use it to find a puzzle that is "just 
harder" than our desired score.

Still working on this.


Finished this part.  Now it shoots high, then solves one step at a time until
it finds a puzzle that is just at or below the target score.


Problem:  It is non-deterministic.

The timing portions of the code (giving up after t seconds) cause the 
hillClimbing to stop in slightly different places each time (even with same
starting parameters).

Solution:  don't stop after a certain time has passed, but instead after
performing a certain number of steps.

Great... it's working and now produces repeatable output.

Still need to generate a spectrum of puzzles and test them on human subjects. 


April 15, 2006

Fixed a bug in solver where it counted progress in methods B, C, and D as steps.

Checked for memory leaks.


test puzzles:

7 50
8 75
9 110
10 170
11 320


Note sudokusolver.co.uk scores differ:

9 107  is scored as 101
10 169  is scored as 319
11 319  is scored 574

It seems like they stick with multiple rounds of an advanced method (like D)
even though they could go back to an easier method and make more progress.
This makes their solver slower, and it also inflates scores.

I don't imagine that a human would exhaustively apply a hard method when
easier options for progress are available.


Also, when running on 11 320, something strange happened with the return
value:

Generating EPS files 11_puzzle_319.eps and 11_solution.eps
Generating latex file 11_puzzle_319_layout.tex
File 11_puzzle_63_layout.tex does not exist.

Why did the program return 63?

Problem:  return codes are limited to 8 bits.



April 24, 2006

Fixed issue with return codes by having score written to a text file.
Scripts read the score in after puzzle is generated.


Note:  I was able to solve a Severe puzzle, but it took me a whole week of
staring at it.

Need to generate 5 puzzles for the month of May, 2006:

7   75  Medium
8  130  Hard
9  210  Intense
10 320  Severe
11  50  Easy


Problem:  To get a puzzle with a score of 70, we hill climb until we find a 
higher score, then we partially solve the puzzle until the score is at or below
70.  The problem?  The solver tends to fill in the first rows first, making
and ugly, off-balance puzzle:

|-  8  - |2  1  9 |7  4  3|
|4  7  1 |5  3  8 |9  6  2|
|-  3  - |-  4  7 |-  -  1|
---------------------------
|-  -  - |-  6  - |3  -  -|
|2  -  - |7  -  - |-  9  -|
|-  -  4 |-  8  - |-  -  -|
---------------------------
|-  -  9 |-  -  - |5  8  -|
|-  -  8 |4  2  6 |-  -  -|
|-  -  - |8  -  - |-  -  -|

Compact: _8_219743+471538962+_3__47__1+____6_3__+2__7___9_+__4_8____+__9___58_+__8426___+___8_____


Fix:  don't solve one step, but instead fill in one cell using the solution.


Back to generating for the month of may



New problem:
Calling ./makePuzzleEPS 8 130
results in a puzzle with a score of 71.  Filling in one (very bad) cell in the 
130 puzzle results in the score dropping nearly 60 points.

Instead, we need to retract our fill-in if we discover that the score has
dropped too far.

Fixed this.

Back to month of may.

Result:

7 73
8 129
9 209
10 318
11 50



May 29, 2006

Strange:  Bill McKently said the Intense puzzle two weeks ago was harder than
last week's Severe puzzle.

Indeed the online web solver thinks the Intense puzzle is harder, too.

Why does my solver differ from the web solver so much?

One answer:  my solver backs out of the more advanced methods, and reverts to
trying the simpler methods again, after making one step of progress with the
advanced method.  The online solver seems to apply a given advanced method
to exhaustion before returning to simpler methods (thus inflating the score).

Something to look at in the future.  Don't have time to deal with it now.



Need to generate 4 puzzles for the month of June, 2006:

12   75  Medium
13  130  Hard
14  210  Intense
15  320  Severe
